<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modular Diagram3D System</title>
    <style>
        /* ===== BASE STYLES ===== */
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        .demo-container {
            margin-bottom: 40px;
        }
        
        .demo-title {
            font-size: 24px;
            font-weight: 600;
            color: #1e293b;
            margin-bottom: 10px;
        }
        
        .demo-description {
            color: #64748b;
            margin-bottom: 20px;
        }
        
        /* ===== DIAGRAM CONTAINER STYLES ===== */
        .diagram-container {
            position: relative;
            width: 100%;
            height: 500px;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }
        
        .diagram-container canvas {
            display: block;
        }
        
        /* ===== INFO CARD STYLES ===== */
        .diagram-info-card {
            position: absolute;
            min-width: 220px;
            max-width: 300px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 12px;
            border: 1px solid rgba(226, 232, 240, 0.8);
            padding: 16px;
            color: #1e293b;
            font-size: 14px;
            opacity: 0;
            transform: scale(0.9) translateY(10px);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            pointer-events: none;
            z-index: 100;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
        }
        
        .diagram-info-card.visible {
            opacity: 1;
            transform: scale(1) translateY(0);
        }
        
        .diagram-info-card .title {
            font-weight: 600;
            font-size: 16px;
            margin-bottom: 8px;
            color: #0f172a;
        }
        
        .diagram-info-card .layer {
            font-size: 12px;
            color: #64748b;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .diagram-info-card .description {
            color: #475569;
            line-height: 1.4;
        }
        
        /* ===== CONTROLS STYLES ===== */
        .diagram-controls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 200;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(226, 232, 240, 0.8);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
        }
        
        .diagram-controls h3 {
            margin: 0 0 15px 0;
            color: #1e293b;
            font-size: 16px;
            font-weight: 600;
        }
        
        .diagram-controls button {
            background: #3b82f6;
            border: none;
            color: white;
            padding: 8px 16px;
            margin: 4px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: background 0.2s;
        }
        
        .diagram-controls button:hover {
            background: #2563eb;
        }
        
        .diagram-controls button.secondary {
            background: #64748b;
        }
        
        .diagram-controls button.secondary:hover {
            background: #475569;
        }
        
        .diagram-controls button.accent {
            background: #10b981;
        }
        
        .diagram-controls button.accent:hover {
            background: #059669;
        }
        
        /* ===== LEGEND STYLES ===== */
        .diagram-legend {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            padding: 16px;
            border-radius: 12px;
            border: 1px solid rgba(226, 232, 240, 0.8);
            font-size: 12px;
            z-index: 200;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 3px;
            margin-right: 8px;
        }
    </style>
</head>
<body>
    <div class="demo-container">
        <h1 class="demo-title">Hospital Architecture Diagram</h1>
        <p class="demo-description">hospital calculator architecture with BÃ©zier connections</p>
        <div id="diagram1" class="diagram-container"></div>
    </div>
    
    <div class="demo-container">
        <h1 class="demo-title">Simple Network Diagram</h1>
        <p class="demo-description">Simplified network topology using the same modular system</p>
        <div id="diagram2" class="diagram-container"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        /**
         * ===== CORE MODULAR DIAGRAM3D SYSTEM =====
         */
        
        /**
         * Scene Manager - Handles Three.js scene initialization
         */
        class SceneManager {
            constructor(container, options = {}) {
                this.container = container;
                this.options = {
                    background: 0xf1f5f9,
                    frustumSize: 16,
                    cameraDistance: 22,
                    ...options
                };
                
                this.initScene();
                this.initCamera();
                this.initRenderer();
                this.initLights();
                this.bindEvents();
            }
            
            initScene() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(this.options.background);
            }
            
            initCamera() {
                const aspect = this.container.clientWidth / this.container.clientHeight;
                const frustumSize = this.options.frustumSize;
                
                this.camera = new THREE.OrthographicCamera(
                    -frustumSize * aspect / 2,
                    frustumSize * aspect / 2,
                    frustumSize / 2,
                    -frustumSize / 2,
                    0.1,
                    1000
                );
                
                this.setIsometricView();
            }
            
            initRenderer() {
                this.renderer = new THREE.WebGLRenderer({ 
                    antialias: true, 
                    alpha: true 
                });
                this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                this.renderer.outputEncoding = THREE.sRGBEncoding;
                this.container.appendChild(this.renderer.domElement);
            }
            
            initLights() {
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(20, 20, 10);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                this.scene.add(directionalLight);
            }
            
            setIsometricView() {
                const distance = this.options.cameraDistance;
                this.camera.position.set(
                    distance * 0.7,
                    distance * 0.7,
                    distance * 0.7
                );
                this.camera.lookAt(-1, 0, 1);
            }
            
            setTopView() {
                this.camera.position.set(-1, 25, 1);
                this.camera.lookAt(-1, 0, 1);
            }
            
            bindEvents() {
                window.addEventListener('resize', () => this.onWindowResize());
            }
            
            onWindowResize() {
                const aspect = this.container.clientWidth / this.container.clientHeight;
                const frustumSize = this.options.frustumSize;
                this.camera.left = -frustumSize * aspect / 2;
                this.camera.right = frustumSize * aspect / 2;
                this.camera.top = frustumSize / 2;
                this.camera.bottom = -frustumSize / 2;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
            }
            
            render() {
                this.renderer.render(this.scene, this.camera);
            }
            
            dispose() {
                this.renderer.dispose();
                this.container.removeChild(this.renderer.domElement);
            }
        }
        
        /**
         * Connection Point Calculator - Enhanced for modularity
         */
        class ConnectionPointCalculator {
            static getConnectionPoint(element, direction = 'center') {
                const userData = element.userData;
                const basePoint = userData.connectionPoint;
                
                switch (userData.type) {
                    case 'platform':
                        return this.getPlatformConnectionPoint(basePoint, direction);
                    case 'component':
                        return this.getComponentConnectionPoint(basePoint, direction);
                    default:
                        return new THREE.Vector3(basePoint.x, basePoint.y, basePoint.z);
                }
            }
            
            static getPlatformConnectionPoint(basePoint, direction) {
                const offset = 0.26;
                return new THREE.Vector3(
                    basePoint.x,
                    basePoint.y + offset,
                    basePoint.z
                );
            }
            
            static getComponentConnectionPoint(basePoint, direction) {
                return new THREE.Vector3(
                    basePoint.x,
                    basePoint.y,
                    basePoint.z
                );
            }
        }
        
        /**
         * BÃ©zier Curve Generator - Modular curve creation
         */
        class BezierCurveGenerator {
            static createCurve(startPoint, endPoint, options = {}) {
                const {
                    curvature = 2.0,
                    verticalOffset = 1.5,
                    horizontalOffset = 0.3
                } = options;
                
                const distance = startPoint.distanceTo(endPoint);
                const controlPoint1 = this.calculateControlPoint1(startPoint, endPoint, {
                    verticalOffset, horizontalOffset, distance
                });
                const controlPoint2 = this.calculateControlPoint2(startPoint, endPoint, {
                    verticalOffset, horizontalOffset, distance
                });
                
                return new THREE.CubicBezierCurve3(
                    startPoint,
                    controlPoint1,
                    controlPoint2,
                    endPoint
                );
            }
            
            static calculateControlPoint1(start, end, options) {
                const { verticalOffset, horizontalOffset, distance } = options;
                const direction = new THREE.Vector3().subVectors(end, start).normalize();
                const perpendicular = new THREE.Vector3(-direction.z, 0, direction.x);
                
                return new THREE.Vector3(
                    start.x + direction.x * (distance * 0.3) + perpendicular.x * horizontalOffset,
                    start.y + verticalOffset,
                    start.z + direction.z * (distance * 0.3) + perpendicular.z * horizontalOffset
                );
            }
            
            static calculateControlPoint2(start, end, options) {
                const { verticalOffset, horizontalOffset, distance } = options;
                const direction = new THREE.Vector3().subVectors(start, end).normalize();
                const perpendicular = new THREE.Vector3(-direction.z, 0, direction.x);
                
                return new THREE.Vector3(
                    end.x + direction.x * (distance * 0.3) + perpendicular.x * horizontalOffset,
                    end.y + verticalOffset,
                    end.z + direction.z * (distance * 0.3) + perpendicular.z * horizontalOffset
                );
            }
        }
        
        /**
         * Connection Manager - Enhanced for modularity
         */
        class ConnectionManager {
            constructor(scene, options = {}) {
                this.scene = scene;
                this.options = {
                    defaultColor: 0x94a3b8,
                    defaultOpacity: 0.7,
                    arrowColor: 0x3b82f6,
                    animationEnabled: false,
                    ...options
                };
                
                this.connectionGroup = new THREE.Group();
                this.animationGroup = new THREE.Group();
                this.scene.add(this.connectionGroup);
                this.scene.add(this.animationGroup);
                this.curves = [];
                this.animationParticles = [];
            }
            
            addConnection(fromElement, toElement, options = {}) {
                const fromPoint = ConnectionPointCalculator.getConnectionPoint(fromElement, 'output');
                const toPoint = ConnectionPointCalculator.getConnectionPoint(toElement, 'input');
                
                const curveOptions = { ...this.options, ...options };
                const curve = BezierCurveGenerator.createCurve(fromPoint, toPoint, curveOptions);
                this.curves.push(curve);
                
                this.createCurveVisual(curve, curveOptions);
                this.createArrow(curve, curveOptions);
                
                if (this.options.animationEnabled) {
                    this.createAnimationParticle(curve);
                }
            }
            
            createCurveVisual(curve, options = {}) {
                const {
                    color = this.options.defaultColor,
                    opacity = this.options.defaultOpacity,
                    segments = 50
                } = options;
                
                const points = curve.getPoints(segments);
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({
                    color: color,
                    opacity: opacity,
                    transparent: true
                });
                
                const line = new THREE.Line(geometry, material);
                this.connectionGroup.add(line);
            }
            
            createArrow(curve, options = {}) {
                const arrowColor = options.arrowColor || this.options.arrowColor;
                const arrowSize = options.arrowSize || 0.3;
                
                const arrowPoint = curve.getPointAt(0.9);
                const endPoint = curve.getPointAt(1.0);
                
                const arrowGeometry = new THREE.ConeGeometry(arrowSize * 0.5, arrowSize, 8);
                const arrowMaterial = new THREE.MeshLambertMaterial({ 
                    color: arrowColor,
                    transparent: true,
                    opacity: 0.8
                });
                
                const arrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
                arrow.position.copy(arrowPoint);
                arrow.lookAt(endPoint);
                arrow.rotateX(Math.PI / 2);
                
                this.connectionGroup.add(arrow);
            }
            
            createAnimationParticle(curve) {
                const particleGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const particleMaterial = new THREE.MeshLambertMaterial({
                    color: 0x10b981,
                    emissive: 0x059669,
                    emissiveIntensity: 0.3
                });
                
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                particle.userData = {
                    curve: curve,
                    progress: 0,
                    speed: 0.01 + Math.random() * 0.02
                };
                
                this.animationParticles.push(particle);
                this.animationGroup.add(particle);
            }
            
            updateAnimations() {
                if (!this.options.animationEnabled) return;
                
                this.animationParticles.forEach(particle => {
                    particle.userData.progress += particle.userData.speed;
                    if (particle.userData.progress >= 1) {
                        particle.userData.progress = 0;
                    }
                    
                    const point = particle.userData.curve.getPointAt(particle.userData.progress);
                    particle.position.copy(point);
                    
                    const pulse = Math.sin(particle.userData.progress * Math.PI * 4) * 0.3 + 0.7;
                    particle.scale.setScalar(pulse);
                });
            }
            
            toggleAnimation() {
                this.options.animationEnabled = !this.options.animationEnabled;
                
                if (this.options.animationEnabled) {
                    this.curves.forEach(curve => this.createAnimationParticle(curve));
                } else {
                    this.animationParticles.forEach(particle => {
                        this.animationGroup.remove(particle);
                    });
                    this.animationParticles = [];
                }
            }
            
            setVisible(visible) {
                this.connectionGroup.visible = visible;
                this.animationGroup.visible = visible;
            }
            
            clear() {
                this.connectionGroup.clear();
                this.animationGroup.clear();
                this.curves = [];
                this.animationParticles = [];
            }
        }
        
        /**
         * UI Manager - Handles info cards, controls, and legends
         */
        class UIManager {
            constructor(diagram) {
                this.diagram = diagram;
                this.infoCard = null;
                this.controls = null;
                this.legend = null;
                this.createUI();
            }
            
            createUI() {
                this.createInfoCard();
                this.createControls();
                this.createLegend();
            }
            
            createInfoCard() {
                this.infoCard = document.createElement('div');
                this.infoCard.className = 'diagram-info-card';
                this.infoCard.innerHTML = `
                    <div class="layer"></div>
                    <div class="title"></div>
                    <div class="description"></div>
                `;
                this.diagram.container.appendChild(this.infoCard);
            }
            
            createControls() {
                if (!this.diagram.options.showControls) return;
                
                this.controls = document.createElement('div');
                this.controls.className = 'diagram-controls';
                this.controls.innerHTML = `
                    <h3>Architecture Views</h3>
                    <button onclick="diagram${this.diagram.id}.sceneManager.setIsometricView()">Isometric</button>
                    <button onclick="diagram${this.diagram.id}.sceneManager.setTopView()">Top View</button>
                    <br>
                    <button onclick="diagram${this.diagram.id}.toggleConnections()" class="secondary">Toggle Connections</button>
                    <br>
                    <button onclick="diagram${this.diagram.id}.connectionManager.toggleAnimation()" class="accent">Animated Flow</button>
                `;
                this.diagram.container.appendChild(this.controls);
            }
            
            createLegend() {
                if (!this.diagram.options.showLegend) return;
                
                this.legend = document.createElement('div');
                this.legend.className = 'diagram-legend';
                
                const legendItems = this.diagram.options.legendItems || [];
                const legendHTML = legendItems.map(item => 
                    `<div class="legend-item">
                        <div class="legend-color" style="background: ${item.color};"></div>
                        <span>${item.label}</span>
                    </div>`
                ).join('');
                
                this.legend.innerHTML = legendHTML;
                this.diagram.container.appendChild(this.legend);
            }
            
            updateInfoCard(component, mouseEvent) {
                const layer = this.infoCard.querySelector('.layer');
                const title = this.infoCard.querySelector('.title');
                const description = this.infoCard.querySelector('.description');
                
                layer.textContent = component.userData.layer || '';
                title.textContent = component.userData.name || '';
                description.textContent = component.userData.info || '';
                
                // Position card
                const rect = this.diagram.container.getBoundingClientRect();
                const x = mouseEvent.clientX - rect.left;
                const y = mouseEvent.clientY - rect.top;
                
                this.infoCard.style.left = Math.min(x + 20, this.diagram.container.clientWidth - 320) + 'px';
                this.infoCard.style.top = Math.max(y - 60, 20) + 'px';
                this.infoCard.classList.add('visible');
            }
            
            hideInfoCard() {
                this.infoCard.classList.remove('visible');
            }
        }
        
        /**
         * Interaction Manager - Handles mouse events and component interactions
         */
        class InteractionManager {
            constructor(diagram) {
                this.diagram = diagram;
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
                this.hoveredComponent = null;
                this.selectedComponent = null;
                this.originalMaterials = new Map();
                this.targetScales = new Map();
                this.targetPositions = new Map();
                
                this.bindEvents();
                this.setupMaterials();
            }
            
            setupMaterials() {
                this.hoverMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x3b82f6,
                    emissive: 0x1e40af,
                    emissiveIntensity: 0.3,
                    opacity: 1,
                    transparent: false
                });
                
                this.selectedMaterial = new THREE.MeshLambertMaterial({
                    color: 0x10b981,
                    emissive: 0x059669,
                    emissiveIntensity: 0.5,
                    opacity: 1,
                    transparent: false
                });
            }
            
            bindEvents() {
                this.diagram.container.addEventListener('mousemove', (e) => this.onMouseMove(e));
                this.diagram.container.addEventListener('click', (e) => this.onMouseClick(e));
            }
            
            onMouseMove(event) {
                const rect = this.diagram.container.getBoundingClientRect();
                this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                
                this.raycaster.setFromCamera(this.mouse, this.diagram.sceneManager.camera);
                const intersects = this.raycaster.intersectObjects(this.diagram.components);
                
                if (intersects.length > 0) {
                    const component = intersects[0].object;
                    
                    if (this.hoveredComponent !== component && component !== this.selectedComponent) {
                        if (this.hoveredComponent && this.hoveredComponent !== this.selectedComponent) {
                            this.resetComponentState(this.hoveredComponent);
                        }
                        
                        this.hoveredComponent = component;
                        component.material = this.hoverMaterial.clone();
                        
                        this.targetScales.set(component, new THREE.Vector3(1.15, 1.15, 1.15));
                        this.diagram.uiManager.updateInfoCard(component, event);
                    }
                } else {
                    if (this.hoveredComponent && this.hoveredComponent !== this.selectedComponent) {
                        this.resetComponentState(this.hoveredComponent);
                        this.hoveredComponent = null;
                        this.diagram.uiManager.hideInfoCard();
                    }
                }
            }
            
            onMouseClick(event) {
                const rect = this.diagram.container.getBoundingClientRect();
                this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                
                this.raycaster.setFromCamera(this.mouse, this.diagram.sceneManager.camera);
                const intersects = this.raycaster.intersectObjects(this.diagram.components);
                
                if (this.selectedComponent) {
                    this.resetComponentState(this.selectedComponent);
                }
                
                if (intersects.length > 0) {
                    const component = intersects[0].object;
                    this.selectedComponent = component;
                    component.material = this.selectedMaterial.clone();
                    this.targetScales.set(component, new THREE.Vector3(1.3, 1.8, 1.3));
                    this.diagram.uiManager.updateInfoCard(component, event);
                } else {
                    this.selectedComponent = null;
                    this.diagram.uiManager.hideInfoCard();
                }
            }
            
            resetComponentState(component) {
                component.material = this.originalMaterials.get(component);
                this.targetScales.set(component, new THREE.Vector3(1, 1, 1));
            }
            
            updateAnimations() {
                const lerpFactor = 0.12;
                
                this.diagram.components.forEach(component => {
                    const targetScale = this.targetScales.get(component);
                    if (targetScale) {
                        component.scale.lerp(targetScale, lerpFactor);
                        
                        if (component === this.selectedComponent) {
                            const time = Date.now() * 0.002;
                            component.position.y = component.userData.originalY + Math.sin(time) * 0.1;
                            
                            if (component.material.emissiveIntensity !== undefined) {
                                component.material.emissiveIntensity = 0.7 + Math.sin(time * 2) * 0.2;
                            }
                        }
                    }
                });
            }
            
            registerComponent(component) {
                this.originalMaterials.set(component, component.material);
                this.targetScales.set(component, new THREE.Vector3(1, 1, 1));
            }
        }
        
        /**
         * MAIN DIAGRAM3D CLASS
         */
        class Diagram3D {
            constructor(config) {
                this.container = typeof config.container === 'string' 
                    ? document.querySelector(config.container) 
                    : config.container;
                    
                this.options = {
                    showControls: true,
                    showLegend: true,
                    enableInteraction: true,
                    animationEnabled: false,
                    ...config.options
                };
                
                this.data = config.data || {};
                this.connections = config.connections || [];
                this.id = Math.random().toString(36).substr(2, 9);
                
                // Core components
                this.components = [];
                this.platforms = {};
                
                this.init();
            }
            
            init() {
                this.sceneManager = new SceneManager(this.container, this.options);
                this.connectionManager = new ConnectionManager(this.sceneManager.scene, this.options);
                this.uiManager = new UIManager(this);
                
                if (this.options.enableInteraction) {
                    this.interactionManager = new InteractionManager(this);
                }
                
                this.createElements();
                this.createConnections();
                this.startAnimationLoop();
                
                // Make globally accessible for controls
                window[`diagram${this.id}`] = this;
            }
            
            createElements() {
                const materials = this.createMaterials();
                
                Object.entries(this.data).forEach(([layerName, layerData]) => {
                    // Create platform if specified
                    if (layerData.platform) {
                        const platform = this.createPlatform(layerData.platform, materials[layerName], layerName);
                        this.platforms[layerName] = platform;
                    }
                    
                    // Create components
                    layerData.components.forEach(comp => {
                        const component = this.createComponent(comp, layerName, layerData.platform !== null);
                        this.components.push(component);
                        
                        if (this.interactionManager) {
                            this.interactionManager.registerComponent(component);
                        }
                    });
                });
            }
            
            createMaterials() {
                return {
                    userInterface: new THREE.MeshLambertMaterial({ color: 0x10b981, opacity: 0.8, transparent: true }),
                    businessLogic: new THREE.MeshLambertMaterial({ color: 0xf59e0b, opacity: 0.8, transparent: true }),
                    output: new THREE.MeshLambertMaterial({ color: 0x8b5cf6, opacity: 0.8, transparent: true }),
                    database: new THREE.MeshLambertMaterial({ color: 0x06b6d4, opacity: 0.8, transparent: true })
                };
            }
            
            createPlatform(platformData, material, layerName) {
                const geometry = new THREE.BoxGeometry(platformData.width, 0.5, platformData.depth);
                const platform = new THREE.Mesh(geometry, material);
                platform.position.set(platformData.x, -0.25, platformData.z);
                platform.receiveShadow = true;
                platform.userData = {
                    type: 'platform',
                    layer: layerName,
                    connectionPoint: { x: platformData.x, y: 0, z: platformData.z }
                };
                this.sceneManager.scene.add(platform);
                return platform;
            }
            
            createComponent(compData, layerName, hasPlataform) {
                const geometry = new THREE.BoxGeometry(1.5, 1.5, 1.5);
                const material = hasPlataform 
                    ? new THREE.MeshLambertMaterial({ color: 0x64748b, opacity: 0.9, transparent: true })
                    : new THREE.MeshLambertMaterial({ color: 0x8b5cf6, opacity: 0.9, transparent: true });
                
                const component = new THREE.Mesh(geometry, material);
                component.position.set(compData.x, 0.75, compData.z);
                component.castShadow = true;
                component.receiveShadow = true;
                
                component.userData = {
                    type: 'component',
                    name: compData.name,
                    layer: layerName,
                    info: compData.info,
                    hasPlataform: hasPlataform,
                    originalY: 0.75,
                    connectionPoint: { x: compData.x, y: 0.75, z: compData.z }
                };
                
                this.sceneManager.scene.add(component);
                return component;
            }
            
            createConnections() {
                this.connections.forEach(conn => {
                    const fromElement = this.findElement(conn.from);
                    const toElement = this.findElement(conn.to);
                    
                    if (fromElement && toElement) {
                        this.connectionManager.addConnection(fromElement, toElement, conn.options);
                    }
                });
            }
            
            findElement(identifier) {
                if (identifier.type === 'platform') {
                    return this.platforms[identifier.layer];
                } else if (identifier.type === 'component') {
                    return this.components.find(c => c.userData.name === identifier.name);
                }
                return null;
            }
            
            toggleConnections() {
                this.connectionManager.setVisible(!this.connectionManager.connectionGroup.visible);
            }
            
            startAnimationLoop() {
                const animate = () => {
                    requestAnimationFrame(animate);
                    
                    this.connectionManager.updateAnimations();
                    if (this.interactionManager) {
                        this.interactionManager.updateAnimations();
                    }
                    
                    this.sceneManager.render();
                };
                animate();
            }
            
            dispose() {
                this.sceneManager.dispose();
                delete window[`diagram${this.id}`];
            }
        }
        
        /**
         * ===== DEMO IMPLEMENTATIONS =====
         */
        
        // Hospital Architecture Diagram (Original)
        const hospitalData = {
            userInterface: {
                platform: { x: -6, z: 6, width: 8, depth: 4 },
                components: [
                    { name: "Input Tables", x: -8, z: 7, info: "Data input interface for user data entry and manipulation" },
                    { name: "Pie Chart", x: -6, z: 7, info: "Visual representation of data in circular chart format" },
                    { name: "Year Selector", x: -4, z: 7, info: "Time-based filtering component for temporal data" },
                    { name: "Bar Chart", x: -8, z: 5, info: "Comparative data visualization using rectangular bars" },
                    { name: "Donut Chart", x: -6, z: 5, info: "Circular chart with center void for additional information" }
                ]
            },
            businessLogic: {
                platform: { x: -6, z: 1, width: 6, depth: 3 },
                components: [
                    { name: "Excel Calculator", x: -7.5, z: 1, info: "Spreadsheet-based calculation engine for complex formulas" },
                    { name: "Web Calculator", x: -4.5, z: 1, info: "Browser-based calculation service for real-time processing" }
                ]
            },
            output: {
                platform: null,
                components: [
                    { name: "Output Tables", x: 4, z: 1, info: "Central processing hub - acts as independent cube without platform" }
                ]
            },
            database: {
                platform: { x: 4, z: -4, width: 6, depth: 3 },
                components: [
                    { name: "AirTable", x: 2, z: -4, info: "Cloud-based database with API integration capabilities" },
                    { name: "Excel", x: 6, z: -4, info: "Traditional spreadsheet storage and processing system" }
                ]
            }
        };
        
        const hospitalConnections = [
            {
                from: { type: 'platform', layer: 'userInterface' },
                to: { type: 'platform', layer: 'businessLogic' },
                options: { color: 0x10b981, opacity: 0.8, curvature: 2.0, verticalOffset: 2.5 }
            },
            {
                from: { type: 'platform', layer: 'businessLogic' },
                to: { type: 'component', name: 'Output Tables' },
                options: { color: 0xf59e0b, opacity: 0.8, curvature: 2.2, verticalOffset: 2.0 }
            },
            {
                from: { type: 'component', name: 'Output Tables' },
                to: { type: 'platform', layer: 'database' },
                options: { color: 0x8b5cf6, opacity: 0.8, curvature: 2.5, verticalOffset: 2.8 }
            }
        ];
        
        // Simple Network Diagram
        const networkData = {
            frontend: {
                platform: { x: -8, z: 0, width: 4, depth: 4 },
                components: [
                    { name: "React App", x: -8, z: 1, info: "Frontend React application" },
                    { name: "Vue App", x: -8, z: -1, info: "Frontend Vue.js application" }
                ]
            },
            backend: {
                platform: null,
                components: [
                    { name: "API Gateway", x: 0, z: 0, info: "Central API management and routing" }
                ]
            },
            services: {
                platform: { x: 8, z: 0, width: 4, depth: 6 },
                components: [
                    { name: "Auth Service", x: 6, z: 1, info: "Authentication and authorization service" },
                    { name: "Data Service", x: 10, z: 1, info: "Data processing and management service" },
                    { name: "Cache", x: 8, z: -1, info: "Redis caching layer" }
                ]
            }
        };
        
        const networkConnections = [
            {
                from: { type: 'platform', layer: 'frontend' },
                to: { type: 'component', name: 'API Gateway' },
                options: { color: 0x3b82f6, opacity: 0.8 }
            },
            {
                from: { type: 'component', name: 'API Gateway' },
                to: { type: 'platform', layer: 'services' },
                options: { color: 0x10b981, opacity: 0.8 }
            }
        ];
        
        // Initialize diagrams
        const diagram1 = new Diagram3D({
            container: '#diagram1',
            data: hospitalData,
            connections: hospitalConnections,
            options: {
                showControls: true,
                showLegend: true,
                legendItems: [
                    { color: '#10b981', label: 'User Interface Layer' },
                    { color: '#f59e0b', label: 'Calculators Layer' },
                    { color: '#8b5cf6', label: 'Output Layer (Central Cube)' },
                    { color: '#06b6d4', label: 'Database Layer' }
                ]
            }
        });
        
        const diagram2 = new Diagram3D({
            container: '#diagram2',
            data: networkData,
            connections: networkConnections,
            options: {
                showControls: false,
                showLegend: true,
                legendItems: [
                    { color: '#3b82f6', label: 'Frontend Applications' },
                    { color: '#10b981', label: 'API Gateway' },
                    { color: '#8b5cf6', label: 'Backend Services' }
                ]
            }
        });
    </script>
</body>
</html>